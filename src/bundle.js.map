{"version":3,"sources":["webpack:///webpack/bootstrap 4df8bc27d9c9f320e561","webpack:///./~/hyperhtml/hyperhtml.js","webpack:///./src/index.js","webpack:///./src/components/if-data.js","webpack:///./src/components/repeat-data.js","webpack:///./src/components/tick-element.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;AChEA,8BAA8B;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,YAAY,aAAa,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,cAAc,UAAU;AACxB;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,IAAI,aAAa,MAAM,IAAI,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc,EAAE;AACnC,mBAAmB,iBAAiB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qBAAqB,EAAE;AACpD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,CAAC;;AAED;AACA,KAAK,4BAA4B,EAAE;;;;;;;;;;;;AC1iBnC;;AAEA;AACA;AACA;AACA;;;;;;;;;;ACLA;;AAEA;;AAEA,gBAAgB;AAChB;AACA;AACA;AACA,GAAG,E;AACH,CAAC;;AAED;;AAEA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qFAA6C,eAAe;AAC5D,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA,yC;;;;;;;;;AC5EA;;AAEA;;AAEA;;AAEA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C,SAAS;AACT;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;;AAEA;AACA,aAAa,UAAU;AACvB;AACA;;;AAGA;;AAEA;AACA,iD;;;;;;;;;AC3DA;;AAEA;;AAEA;;AAEA;AACA;AACA,iCAAiC,aAAa;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;;AAEA;;AAEA;AACA,mD","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4df8bc27d9c9f320e561","var hyperHTML = (function () {'use strict';\n\n  /*! (C) 2017 Andrea Giammarchi @WebReflection (MIT) */\n\n  // hyperHTML \\o/\n  //\n  // var render = hyperHTML.bind(document.body);\n  // setInterval(() => render`\n  //  <h1>⚡️ hyperHTML ⚡️</h1>\n  //  <p>\n  //    ${(new Date).toLocaleString()}\n  //  </p>\n  // `, 1000);\n  function hyperHTML(statics) {\n    return  EXPANDO in this &&\n            this[EXPANDO].s === statics ?\n              update.apply(this, arguments) :\n              upgrade.apply(this, arguments);\n  }\n\n  // A wire ➰ is a bridge between a document fragment\n  // and its inevitably lost list of rendered nodes\n  //\n  // var render = hyperHTML.wire();\n  // render`\n  //  <div>Hello Wired!</div>\n  // `;\n  //\n  // Every single invocation will return that div\n  // or the list of elements it contained as Array.\n  // This simplifies most task where hyperHTML\n  // is used to create the node itself, instead of\n  // populating an already known and bound one.\n  hyperHTML.wire = function wire(obj, type) {\n    return arguments.length < 1 ?\n      wireContent('html') :\n      (obj == null ?\n        wireContent(type || 'html') :\n        (wm.get(obj) || wireWeakly(obj, type || 'html'))\n      );\n  };\n\n  // - - - - - - - - - - - - - - - - - -  - - - - -\n\n  // -------------------------\n  // DOM parsing & traversing\n  // -------------------------\n\n  // setup attributes for updates\n  //\n  // <p class=\"${state.class}\" onclick=\"${event.click}\"></p>\n  //\n  // Note: always use quotes around attributes, even for events,\n  //       booleans, or numbers, otherwise this function fails.\n  function attributesSeeker(node, actions) {\n    for (var\n      attribute,\n      value = IE ? uid : uidc,\n      attributes = slice.call(node.attributes),\n      i = 0,\n      length = attributes.length;\n      i < length; i++\n    ) {\n      attribute = attributes[i];\n      if (attribute.value === value) {\n        // with IE the order doesn't really matter\n        // as long as the right attribute is addressed\n        actions.push(setAttribute(node, IE ?\n          node.getAttributeNode(IEAttributes.shift()) :\n          attribute\n        ));\n      }\n    }\n  }\n\n  // traverse the whole node in search of editable content\n  // decide what each future update should change\n  //\n  // <div atr=\"${some.attribute}\">\n  //    <h1>${some.HTML}</h1>\n  //    <p>\n  //      ${some.text}\n  //    </p>\n  // </div>\n  function lukeTreeWalker(node, actions) {\n    for (var\n      child, text,\n      childNodes = slice.call(node.childNodes),\n      length = childNodes.length,\n      i = 0; i < length; i++\n    ) {\n      child = childNodes[i];\n      switch (child.nodeType) {\n        case 1:\n          attributesSeeker(child, actions);\n          lukeTreeWalker(child, actions);\n          break;\n        case 8:\n          if (child.textContent === uid) {\n            if (length === 1) {\n              actions.push(setAnyContent(node));\n              node.removeChild(child);\n            } else if (\n              (i < 1 || childNodes[i - 1].nodeType === 1) &&\n              (i + 1 === length || childNodes[i + 1].nodeType === 1)\n            ) {\n              actions.push(setVirtualContent(child));\n            } else {\n              text = node.ownerDocument.createTextNode('');\n              actions.push(setTextContent(text));\n              node.replaceChild(text, child);\n            }\n          }\n          break;\n        case 3:\n          if (node.nodeName === 'STYLE' && child.textContent === uidc) {\n            actions.push(setTextContent(node));\n          }\n          break;\n      }\n    }\n  }\n\n\n  // -------------------------\n  // DOM manipulating\n  // -------------------------\n\n  // update regular bound nodes\n  //\n  // var render = hyperHTML.bind(node);\n  // function update() {\n  //  render`template`;\n  // }\n  function setAnyContent(node) {\n    return function any(value) {\n      switch (typeof value) {\n        case 'string':\n          node.innerHTML = value;\n          break;\n        case 'number':\n        case 'boolean':\n          node.textContent = value;\n          break;\n        default:\n          if (Array.isArray(value)) {\n            if (value.length === 1) {\n              any(value[0]);\n            } else if(typeof value[0] === 'string') {\n              any(value.join(''));\n            } else {\n              var i = indexOfDiffereces(node.childNodes, value);\n              if (-1 < i) {\n                updateViaArray(node, value, i);\n              }\n            }\n          } else {\n            populateNode(node, value);\n          }\n          break;\n      }\n    };\n  }\n\n  // update attributes node\n  //\n  // render`<a href=\"${url}\" onclick=\"${click}\">${name}</a>`;\n  //\n  // Note: attributes with a special meaning like DOM Level 0\n  //       listeners or accessors properties are directly set\n  function setAttribute(node, attribute) {\n    var\n      name = attribute.name,\n      isSpecial = name in node && !SHOULD_USE_ATTRIBUTE.test(name),\n      oldValue\n    ;\n    if (isSpecial) node.removeAttribute(name);\n    return isSpecial ?\n      function specialAttr(newValue) {\n        if (oldValue !== newValue) {\n          node[name] = (oldValue = newValue);\n        }\n      } :\n      function attr(newValue) {\n        if (oldValue !== newValue) {\n          attribute.value = (oldValue = newValue);\n        }\n      };\n  }\n\n  // update the \"emptiness\"\n  // this function is used when template literals\n  // have sneaky html/fragment capable\n  // updates in the wild (no spaces around)\n  //\n  // render`\n  //  <p>Content before</p>${\n  //  'any content in between'\n  //  }<p>Content after</p>\n  // `;\n  //\n  // Note: this is the most expensive\n  //       update of them all.\n  function setVirtualContent(node) {\n    var\n      fragment = document.createDocumentFragment(),\n      childNodes = []\n    ;\n    return function any(value) {\n      var i, parentNode = node.parentNode;\n      switch (typeof value) {\n        case 'string':\n        case 'number':\n        case 'boolean':\n          removeNodeList(childNodes, 0);\n          injectHTML(fragment, value);\n          childNodes = slice.call(fragment.childNodes);\n          parentNode.insertBefore(fragment, node);\n          break;\n        default:\n          if (Array.isArray(value)) {\n            if (value.length === 0) {\n              any(value[0]);\n            } else if(typeof value[0] === 'string') {\n              any(value.join(''));\n            } else {\n              i = indexOfDiffereces(childNodes, value);\n              if (-1 < i) {\n                removeNodeList(childNodes, i);\n                value = value.slice(i);\n                appendNodes(fragment, value);\n                parentNode.insertBefore(fragment, node);\n                childNodes.push.apply(childNodes, value);\n              }\n            }\n          } else {\n            removeNodeList(childNodes, 0);\n            childNodes = value.nodeType === 11 ?\n              slice.call(value.childNodes) :\n              [value];\n            parentNode.insertBefore(value, node);\n          }\n          break;\n      }\n    };\n  }\n\n  // basic closure to update nodes textContent\n  //\n  // render`\n  //  <p>\n  //    ${'spaces around means textContent'}\n  //  </p>`;\n  function setTextContent(node) {\n    var oldValue;\n    return function text(newValue) {\n      if (oldValue !== newValue) {\n        node.textContent = (oldValue = newValue);\n      }\n    };\n  }\n\n\n  // -------------------------\n  // Helpers\n  // -------------------------\n\n  // it does exactly what it says\n  function appendNodes(node, childNodes) {\n    for (var\n      i = 0,\n      length = childNodes.length;\n      i < length; i++\n    ) {\n      node.appendChild(childNodes[i]);\n    }\n  }\n\n  // given two collections, find\n  // the first index that has different content.\n  // If the two lists are the same, return -1\n  // to indicate no differences were found.\n  function indexOfDiffereces(a, b) {\n    if (a === b) return -1;\n    var\n      i = 0,\n      aLength = a.length,\n      bLength = b.length\n    ;\n    while (i < aLength) {\n      if (i < bLength && a[i] === b[i]) i++;\n      else return i;\n    }\n    return i === bLength ? -1 : i;\n  }\n\n  // inject HTML into a template node\n  // and populate a fragment with resulting nodes\n  //\n  // IE9~IE11 are not compatible with the template tag.\n  // If the content is a partial part of a table there is a fallback.\n  // Not the most elegant/robust way but good enough for common cases.\n  // (I don't want to include a whole DOM parser for IE only here).\n  function injectHTML(fragment, html) {\n    var\n      fallback = IE && /^[^\\S]*?<(t(?:head|body|foot|r|d|h))/i.test(html),\n      template = fragment.ownerDocument.createElement('template')\n    ;\n    template.innerHTML = fallback ? ('<table>' + html + '</table>') : html;\n    if (fallback) {\n      template = {childNodes: template.querySelectorAll(RegExp.$1)};\n    }\n    appendNodes(\n      fragment,\n      slice.call((template.content || template).childNodes)\n    );\n  }\n\n  // accordingly with the kind of child\n  // it puts its content into a parent node\n  function populateNode(parent, child) {\n    switch (child.nodeType) {\n      case 1:\n        var\n          childNodes = parent.childNodes,\n          length = childNodes.length\n        ;\n        if (0 < length && childNodes[0] === child) {\n          removeNodeList(childNodes, 1);\n        } else if (length !== 1) {\n          resetAndPopulate(parent, child);\n        }\n        break;\n      case 11:\n        if (-1 < indexOfDiffereces(parent.childNodes, child.childNodes)) {\n          resetAndPopulate(parent, child);\n        }\n        break;\n      case 3:\n        parent.textContent = child.textContent;\n        break;\n    }\n  }\n\n  // it does exactly what it says\n  function removeNodeList(list, startIndex) {\n    var length = list.length, child;\n    while (startIndex < length--) {\n      child = list[length];\n      child.parentNode.removeChild(child);\n    }\n  }\n\n  // drop all nodes and append a node\n  function resetAndPopulate(parent, child) {\n    parent.textContent = '';\n    parent.appendChild(child);\n  }\n\n  // the first time a hyperHTML.wire() is invoked\n  // remember the list of nodes that should be updated\n  // at every consequent render call.\n  // The resulting function might return the very first node\n  // or the Array of all nodes that might need updates.\n  function setupAndGetContent(node) {\n    for (var\n      child,\n      children = [],\n      childNodes = node.childNodes,\n      i = 0,\n      length = childNodes.length;\n      i < length; i++\n    ) {\n      child = childNodes[i];\n      if (\n        1 === child.nodeType ||\n        0 < trim.call(child.textContent).length\n      ) {\n        children.push(child);\n      }\n    }\n    length = children.length;\n    return length < 2 ?\n      ((child = length < 1 ? node : children[0]),\n      function () { return child; }) :\n      function () { return children; };\n  }\n\n  // remove and/or and a list of nodes through an array\n  function updateViaArray(node, childNodes, i) {\n    var fragment = node.ownerDocument.createDocumentFragment();\n    if (0 < i) {\n      removeNodeList(node.childNodes, i);\n      appendNodes(fragment, childNodes.slice(i));\n      node.appendChild(fragment);\n    } else {\n      appendNodes(fragment, childNodes);\n      resetAndPopulate(node, fragment);\n    }\n  }\n\n  // create a new wire for generic DOM content\n  function wireContent(type) {\n    var content, container, fragment, render, setup, template;\n    return function update(statics) {\n      if (template !== statics) {\n        setup = true;\n        template = statics;\n        fragment = document.createDocumentFragment();\n        container = type === 'svg' ?\n          document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n          fragment;\n        render = hyperHTML.bind(container);\n      }\n      render.apply(null, arguments);\n      if (setup) {\n        setup = false;\n        if (type === 'svg') {\n          appendNodes(fragment, slice.call(container.childNodes));\n        }\n        content = setupAndGetContent(fragment);\n      }\n      return content();\n    };\n  }\n\n  // get or create a wired weak reference\n  function wireWeakly(obj, type) {\n    var wire = wireContent(type);\n    wm.set(obj, wire);\n    return wire;\n  }\n\n  // -------------------------\n  // Template setup\n  // -------------------------\n\n  // each known hyperHTML update is\n  // kept as simple as possible.\n  function update() {\n    for (var\n      i = 1,\n      length = arguments.length,\n      updates = this[EXPANDO].u;\n      i < length; i++\n    ) {\n      updates[i - 1](arguments[i]);\n    }\n    return this;\n  }\n\n  // but the first time, it needs to be setup.\n  // From now on, only update(statics) will be called\n  // unless this node won't be used for other renderings.\n  function upgrade(statics) {\n    var\n      updates = [],\n      html = statics.join(uidc)\n    ;\n    if (IE) {\n      IEAttributes = [];\n      injectHTML(this, html.replace(no, comments));\n    } else if (this.nodeType === 1) {\n      this.innerHTML = html;\n    } else {\n      injectHTML(this, html);\n    }\n    lukeTreeWalker(this, updates);\n    this[EXPANDO] = {s: statics, u: updates};\n    return update.apply(this, arguments);\n  }\n\n  // -------------------------\n  // the trash bin\n  // -------------------------\n\n  // IE used to suck.\n  /*\n  // even in a try/catch this throw an error\n  // since it's reliable though, I'll keep it around\n  function isIE() {\n    var p = document.createElement('p');\n    p.innerHTML = '<i onclick=\"<!---->\">';\n    return p.childNodes[0].onclick == null;\n  }\n  //*/\n\n  // remove and/or add a list of nodes through a fragment\n  /* temporarily removed until it's demonstrated it's needed\n  function updateViaFragment(node, fragment, i) {\n    if (0 < i) {\n      removeNodeList(node.childNodes, i);\n      var slim = fragment.cloneNode();\n      appendNodes(slim, slice.call(fragment.childNodes, i));\n      node.appendChild(fragment, slim);\n    } else {\n      resetAndPopulate(node, fragment);\n    }\n  }\n  //*/\n\n  // -------------------------\n  // local variables\n  // -------------------------\n\n  var\n    // some attribute might be present on the element prototype but cannot be set directly\n    SHOULD_USE_ATTRIBUTE = /^style$/i,\n    // avoids WeakMap to avoid memory pressure, use CSS compatible syntax for IE\n    EXPANDO = '_hyper_html: ',\n    // use a pseudo unique id to avoid conflicts and normalize CSS style for IE\n    uid = EXPANDO + ((Math.random() * new Date) | 0) + ';',\n    // use comment nodes with pseudo unique content to setup\n    uidc = '<!--' + uid + '-->',\n    // threat it differently\n    IE = 'documentMode' in document,\n    no = IE && new RegExp('([^\\\\S][a-z]+[a-z0-9_-]*=)([\\'\"])' + uidc + '\\\\2', 'g'),\n    comments = IE && function ($0, $1, $2) {\n      IEAttributes.push($1.slice(1, -1));\n      return $1 + $2 + uid + $2;\n    },\n    // verify empty textContent on .wire() setup\n    trim = EXPANDO.trim || function () {\n      return this.replace(/^\\s+|\\s+$/g, '');\n    },\n    // convert DOM.childNodes into arrays to avoid\n    // DOM mutation backfiring on loops\n    slice = [].slice,\n    // used for weak references\n    // if WeakMap is not available\n    // it uses a configurable, non enumerable,\n    // quick and dirty expando property.\n    wm = typeof WeakMap === typeof wm ?\n      {\n        get: function (obj) { return obj[EXPANDO]; },\n        set: function (obj, value) {\n          Object.defineProperty(obj, EXPANDO, {\n            configurable: true,\n            value: value\n          });\n        }\n      } :\n      new WeakMap(),\n    IEAttributes\n  ;\n\n  // -------------------------\n  // ⚡️ ️️The End ➰\n  // -------------------------\n  return hyperHTML;\n\n}());\n\n// umd.KISS\ntry { module.exports = hyperHTML; } catch(o_O) {}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/hyperhtml/hyperhtml.js\n// module id = 0\n// module chunks = 0","'use strict';\r\n\r\n// import './other/tick-example';\r\nimport './components/tick-element';\r\nimport './components/repeat-data';\r\nimport './components/if-data';\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 1\n// module chunks = 0","'use strict';\r\n\r\nimport hyperHTML from 'hyperhtml';\r\n\r\nconst config = { attributes: true };\r\nconst observer = new MutationObserver(function(mutations) {\r\n  mutations.forEach(function(mutation) {\r\n    console.log(mutation.type);\r\n  });    \r\n});\r\n\r\nclass IfData extends HTMLElement {\r\n\r\n  constructor(){\r\n    super();\r\n    this.SD = this.attachShadow({mode: 'open'});\r\n    this.condition = false;\r\n  }\r\n\r\n /* get condition(){\r\n    return this.gasAttribute('condition');\r\n  }\r\n\r\n  set condition(val){\r\n      console.log(val);\r\n    const bool = val == 'true';\r\n    if(bool){\r\n      this.condition = val == 'true';\r\n      this._render();\r\n      this.setAttribute('condition', true);\r\n    } else {\r\n      this.removeAttribute('condition');\r\n    }\r\n  }*/\r\n\r\n  static get observedAttributes() {\r\n    return ['condition'];\r\n  }\r\n\r\n  attributeChangedCallback(name, oldValue, newValue) {\r\n    console.log(name + ':' + newValue);\r\n    /*this.condition = newValue == 'true';\r\n    this._render();*/\r\n  }\r\n\r\n  connectedCallback(){\r\n    this.SD.innerHTML = `<style>\r\n      :host{\r\n        display: block;\r\n        padding: 10px;\r\n        border: 1px dashed #ccc;\r\n      }\r\n    </style>`;\r\n    console.log('<if-data> added to the DOM');\r\n    observer.observe(this, config);\r\n    this.render = hyperHTML.bind(this.SD);\r\n    this._render();\r\n  }\r\n\r\n  _render(){\r\n    this.render ? this.render`\r\n      <div>${\r\n        hyperHTML.wire()`<button disabled=\"${this.condition}\">Provami</button>`\r\n      }</div>\r\n    ` : null;\r\n    console.log(this.root,this.render,this.condition);\r\n  }\r\n\r\n  update(newValue = true){\r\n    this.condition = newValue;\r\n    this._render();\r\n  }\r\n\r\n\r\n}\r\n\r\ncustomElements.define('if-data', IfData);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/if-data.js\n// module id = 2\n// module chunks = 0","'use strict';\r\n\r\nimport hyperHTML from 'hyperhtml';\r\n\r\nclass RepeatData extends HTMLElement {\r\n\r\n  constructor(){\r\n    super();\r\n    this.SD = this.attachShadow({mode: 'open'});\r\n    this.base = 'http://jsonplaceholder.typicode.com'\r\n    this.data = [];\r\n  }\r\n\r\n  static get observedAttributes() {\r\n    return ['source'];\r\n  }\r\n\r\n  attributeChangedCallback(name, oldValue, newValue) {\r\n    console.log(name + ':' + newValue);\r\n  }\r\n\r\n  connectedCallback(){\r\n    this.SD.innerHTML = `<style>\r\n      :host{\r\n        display: block;\r\n        padding: 10px;\r\n        border: 1px dashed #ccc;\r\n      }\r\n    </style>`;\r\n    console.log('<repeat-data> added to the DOM');\r\n    this.root = hyperHTML.bind(this.SD)\r\n\r\n    this.posts();\r\n  }\r\n\r\n  _renderData(data){\r\n    console.log(data);\r\n      this.data = data;\r\n      this.root`\r\n        <ul>${\r\n          this.data.map(e => `<li>${e.body}</li>`)\r\n        }</ul>\r\n      `\r\n  }\r\n\r\n  posts(){\r\n    fetch(`${this.base}/posts`).then( r => r.json() )\r\n      .then(this._renderData.bind(this));\r\n  }\r\n\r\n  comments(){\r\n    fetch(`${this.base}/comments`).then( r => r.json() )\r\n      .then(this._renderData.bind(this));\r\n  }\r\n\r\n\r\n}\r\n\r\n// Registra il nuovo elemento\r\ncustomElements.define('repeat-data', RepeatData);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/repeat-data.js\n// module id = 3\n// module chunks = 0","'use strict';\r\n\r\nimport hyperHTML from 'hyperhtml';\r\n\r\nclass TickElement extends HTMLElement {\r\n\r\n  constructor(){\r\n    super();\r\n    this.SD = this.attachShadow({mode: 'open'});\r\n  }\r\n\r\n  connectedCallback(){\r\n    this.SD.innerHTML = `<style>\r\n      :host{\r\n        display: block;\r\n        padding: 10px;\r\n        border: 1px dashed #ccc;\r\n      }\r\n    </style>`;\r\n    console.log('<tick-element> added to the DOM');\r\n    setInterval(this._tick, 1000,\r\n      hyperHTML.bind(this.SD)\r\n    );\r\n  }\r\n\r\n  _tick(render) {\r\n    render `\r\n      <div>\r\n        <h1>Hello, world!</h1>\r\n        <h2>It is ${new Date().toLocaleTimeString()}.</h2>\r\n      </div>\r\n    `;\r\n  }\r\n\r\n}\r\n\r\n// Registra il nuovo elemento\r\ncustomElements.define('tick-element', TickElement);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/components/tick-element.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}